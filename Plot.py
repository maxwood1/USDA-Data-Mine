import numpy as np
import matplotlib.pyplot as plt
from sklearn.neighbors import KernelDensity
import matplotlib.colors as colors
import matplotlib.ticker as ticker
from progress.bar import Bar
import matplotlib.cm as cm


################################################################################
# This program reads in 3 npy files '[state]_simulated_[strat%].npy'.
# These files must be generated by the Simulate.py program.
#
# It uses these data files to make cool plots showing the comparisons between
# them, i.e.: which method is better in what circumstances.
################################################################################

# Change this prefix to be your file path.
file_path_prefix = "/Users/michael/Desktop/Forestry/Simulation plots/"

state='TX'

# Read in the files generated by Simulate.py (It reads in 3 for 3 different
# stratification breakpoints)
[X,Y,strats_5, boths_5] = np.load(file_path_prefix+state+"_simulated_5.npy")
[_,_,strats_25,boths_25]= np.load(file_path_prefix+state+"_simulated_25.npy")
[_,_,strats_50,boths_50]= np.load(file_path_prefix+state+"_simulated_50.npy")

# I want to plot these on a logarithmic scale, so I mask away all of the areas
# that have a 0 value (log(0) is undefined)
str_mask_5 = np.ma.masked_equal(strats_5, 0.0, copy=False)
bot_mask_5 = np.ma.masked_equal(boths_5,  0.0, copy=False)
str_mask_25= np.ma.masked_equal(strats_25,0.0, copy=False)
bot_mask_25= np.ma.masked_equal(boths_25, 0.0, copy=False)
str_mask_50= np.ma.masked_equal(strats_50,0.0, copy=False)
bot_mask_50= np.ma.masked_equal(boths_50, 0.0, copy=False)

# Calculate the difference of errors between the two methods, a positive value
# means that removing the remote plots from the estimate leads to more error
diffs_5 = boths_5 - strats_5
diffs_25= boths_25- strats_25
diffs_50= boths_50- strats_50

# Find the total minimum and maximum values to have a consistent color scale
# across all the plots.
minner = np.min([np.min(str_mask_5),np.min(bot_mask_5),np.min(str_mask_25),np.min(bot_mask_25),np.min(str_mask_50),np.min(bot_mask_50)])
maxxed = np.max([np.max(str_mask_5),np.max(bot_mask_5),np.max(str_mask_25),np.max(bot_mask_25),np.max(str_mask_50),np.max(bot_mask_50)])
levels = np.logspace(np.log10(minner),np.log10(np.max(maxxed)),15)
print(minner, maxxed)

# Set up the figure, with the correct color map and correct logarithmic scale
fig = plt.figure()
cmap=cm.get_cmap('magma')
normalizer=colors.LogNorm(minner,maxxed)
im=cm.ScalarMappable(norm=normalizer, cmap = cmap)

# Find the mins and maxes for the method error differences
d_min = np.min([np.min(diffs_5),np.min(diffs_25),np.min(diffs_50)])
d_max = np.max([np.max(diffs_5),np.max(diffs_25),np.max(diffs_50)])

# It looks bad if one method is ALWAYS better than another, so change the
# colormap to handle this
if(d_min==0):
    # cmap_str = 'Reds'
    d_cmap = colors.LinearSegmentedColormap.from_list("", ["white","red"])
else:
    d_cmap = cm.get_cmap('bwr')

if(abs(d_min)>abs(d_max)):
    if(d_max > 0):
        d_min = -d_max
else:
    if(d_min<0):
        d_max = -d_min

# Generate the color scale for the error difference plots.
d_lev = np.linspace(d_min,d_max,50)
# d_norm=colors.TwoSlopeNorm(vmin=d_min, vcenter=0, vmax=d_max)
d_norm=colors.Normalize(d_min,d_max)
d_im=cm.ScalarMappable(norm=d_norm, cmap = d_cmap)

# Set up the plots to be a 3x3 grid (for 3 stratification breakpoints)
gs = fig.add_gridspec(3, 3)
axs = gs.subplots(sharex='col', sharey='row')

# Make all of the plots
axs[0,0].contourf(X,Y,bot_mask_5, levels=levels,extend="both",cmap="magma",norm=colors.LogNorm())
axs[1,0].contourf(X,Y,str_mask_5, levels=levels,extend="both",cmap="magma",norm=colors.LogNorm())
# axs[2,0].contourf(X,Y,diffs_5, levels=d_lev,extend="both",cmap=cmap_str, norm=colors.TwoSlopeNorm(vmin=d_min, vcenter=0, vmax=d_max))
axs[2,0].contourf(X,Y,diffs_5, levels=d_lev,extend="both",cmap=d_cmap, norm=d_norm)

axs[0,1].contourf(X,Y,bot_mask_25,levels=levels,extend="both",cmap="magma",norm=colors.LogNorm())
axs[1,1].contourf(X,Y,str_mask_25,levels=levels,extend="both",cmap="magma",norm=colors.LogNorm())
# axs[2,1].contourf(X,Y,diffs_25, levels=d_lev,extend="both",cmap=cmap_str, norm=colors.TwoSlopeNorm(vmin=d_min, vcenter=0, vmax=d_max))
axs[2,1].contourf(X,Y,diffs_25, levels=d_lev,extend="both",cmap=d_cmap, norm=d_norm)

axs[0,2].contourf(X,Y,bot_mask_50,levels=levels,extend="both",cmap="magma",norm=colors.LogNorm())
axs[1,2].contourf(X,Y,str_mask_50,levels=levels,extend="both",cmap="magma",norm=colors.LogNorm())
# axs[2,2].contourf(X,Y,diffs_50, levels=d_lev,extend="both",cmap=cmap_str, norm=colors.TwoSlopeNorm(vmin=d_min, vcenter=0, vmax=d_max))
axs[2,2].contourf(X,Y,diffs_50, levels=d_lev,extend="both",cmap=d_cmap, norm=d_norm)

# Set all the plot labels
fig.text(0.42, 0.95, "Comparison of Estimation Methods", ha='center', va='center')
fig.text(0.06, 0.5, 'Non-Response Rate', ha='center', va='center', rotation='vertical')
fig.text(0.5, 0.04, 'Remote Sensing Rate', ha='center', va='center')

axs[0,0].set_title('5%')
axs[0,1].set_title('25%')
axs[0,2].set_title('50%')

# Make the color bars
cbar = fig.colorbar(im, ax=axs[0:2, :], location='right')
cbar.set_label('Mean Square Error')
d_cbar = fig.colorbar(d_im, ax=axs[2:, :], location='right')
d_cbar.set_label('Difference in Errors')

# Only label the outer plots
for ax in axs.flat:
    ax.set_aspect(1)
    ax.label_outer()

# Save the figure
plt.savefig(file_path_prefix+state+'_Gridded.png', bbox_inches='tight',dpi=1200)
plt.close()
